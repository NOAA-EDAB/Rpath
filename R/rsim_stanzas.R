#'Generate Rsim stanza matrix
#'
#'Creates a matrix of stanza variables to be used by \code{rsim.run}.
#'
#'@inheritParams rsim.scenario
#'@inheritParams rsim.fishing
#'@param state List object of state variables generated by \code{rsim.state}. 
#'
#'@export
#'
rsim.stanzas <- function(Rpath.params, state, params){
  #Need to define variables to eliminate check() note about no visible binding
  StGroupNum <- StanzaNum <- GroupNum <- First <- Last <- WageS <- NageS <- age <- NULL
  QageS <- Cons <- NULL
  
  juvfile <- Rpath.params$stanzas
  if(Rpath.params$stanzas$NStanzaGroups > 0){
    #Set up multistanza parameters to pass to C
    rstan <- list()
    rstan$Nsplit      <- juvfile$NStanzaGroups
    #Need leading zeros (+1 col/row) to make indexing in C++ easier
    rstan$Nstanzas    <- c(0, juvfile$stgroups$nstanzas)
    rstan$EcopathCode <- matrix(NA, rstan$Nsplit + 1, max(rstan$Nstanzas) + 1)
    rstan$Age1        <- matrix(NA, rstan$Nsplit + 1, max(rstan$Nstanzas) + 1)
    rstan$Age2        <- matrix(NA, rstan$Nsplit + 1, max(rstan$Nstanzas) + 1)
    rstan$baseWageS   <- matrix(NA, max(juvfile$stindiv$Last) + 1, rstan$Nsplit + 1)
    rstan$baseNageS   <- matrix(NA, max(juvfile$stindiv$Last) + 1, rstan$Nsplit + 1)
    rstan$baseQageS   <- matrix(NA, max(juvfile$stindiv$Last) + 1, rstan$Nsplit + 1)
    
    sPred <- rep(0, params$NUM_GROUPS + 1) #rstan$stanzaPred  <- rep(0, params$NUM_GROUPS + 1)
    
    for(isp in 1:rstan$Nsplit){
      for(ist in 1:rstan$Nstanzas[isp + 1]){
        rstan$EcopathCode[isp + 1, ist + 1] <- juvfile$stindiv[StGroupNum == isp &
                                                                 StanzaNum == ist, GroupNum]
        rstan$Age1[isp + 1, ist + 1] <- juvfile$stindiv[StGroupNum == isp & 
                                                          StanzaNum == ist, First]
        rstan$Age2[isp + 1, ist + 1] <- juvfile$stindiv[StGroupNum == isp & 
                                                          StanzaNum == ist, Last]
      }
      rstan$baseWageS[1:nrow(juvfile$StGroup[[isp]]), isp + 1] <- juvfile$StGroup[[isp]]$WageS
      rstan$baseNageS[1:nrow(juvfile$StGroup[[isp]]), isp + 1] <- juvfile$StGroup[[isp]]$NageS
      rstan$baseQageS[1:nrow(juvfile$StGroup[[isp]]), isp + 1] <- juvfile$StGroup[[isp]]$QageS
    }
    
    #Maturity
    MIN_REC_FACTOR     <- 6.906754779  #// This is ln(1/0.001 - 1) used to set min. logistic matuirty to 0.001
    rstan$Wmat     <- c(0, juvfile$stgroup$Wmat)
    #rstan$Wmat001  <- c(0, juvfile$stgroup$Wmat001)
    #rstan$Wmat50   <- c(0, juvfile$stgroup$Wmat50)
    #rstan$Amat001  <- c(0, juvfile$stgroup$Amat001)
    #rstan$Amat50   <- c(0, juvfile$stgroup$Amat50)
    #rstan$WmatSpread <- -(rstan$Wmat001 - rstan$Wmat50)/MIN_REC_FACTOR
    #rstan$AmatSpread <- -(rstan$Amat001 - rstan$Amat50)/MIN_REC_FACTOR
    rstan$RecPower <- c(0, juvfile$stgroup$RecPower)
    rstan$recruits <- c(0, juvfile$stgroup$R)
    rstan$vBGFd    <- c(0, juvfile$stgroup$VBGF_d)
    rstan$RzeroS   <- rstan$recruits
    
    #Energy required to grow a unit in weight(scaled to Winf = 1)
    rstan$vBM <- c(0, (1 - 3 * juvfile$stgroups$VBGF_Ksp / 12))
    
    # Spawning Biomass and Eggs
    
    eggs <- c(0) #rstan$baseEggsStanza <- c(0)
    for(isp in 1:rstan$Nsplit){
      #id which weight at age is higher than Wmat
      #rstan$baseEggsStanza[isp + 1]
      # KYA 5/3/18 switchout
      #if ((is.na(rstan$Wmat[isp+1]))|(rstan$Wmat[isp+1]<0)){
      #     eggs[isp + 1] <- 
      #    juvfile$StGroup[[isp]][(WageS>rstan$Wmat001[isp+1])&(age>rstan$Amat001[isp+1]),
      #    sum(WageS*NageS / (1. + exp( -((WageS - rstan$Wmat50[isp+1]) / rstan$WmatSpread[isp+1])   
      #                                  -((age   - rstan$Amat50[isp+1]) / rstan$AmatSpread[isp+1]) ))) ]
      #     rstan$Wmat[isp+1] <- -1.0
      #}
      #else{
      eggs[isp + 1] <- juvfile$StGroup[[isp]][WageS > rstan$Wmat[isp+1], 
                                              sum(NageS * (WageS - rstan$Wmat[isp+1]))]
      #}
    }
    #rstan$EggsStanza <- rstan$baseEggsStanza
    
    #initialize splitalpha growth coefficients using pred information and
    rstan$SplitAlpha <- matrix(NA, max(juvfile$stindiv$Last) + 1, rstan$Nsplit + 1)
    for(isp in 1:rstan$Nsplit){
      for(ist in 1:rstan$Nstanzas[isp + 1]){
        ieco  <- rstan$EcopathCode[isp + 1, ist + 1]
        first <- rstan$Age1[isp + 1, ist + 1]
        last  <- rstan$Age2[isp + 1, ist + 1]
        pred  <- sum(juvfile$StGroup[[isp]][age %in% first:last, NageS * QageS])
        StartEatenBy <- juvfile$stindiv[StGroupNum == isp & StanzaNum == ist, Cons]
        
        SplitAlpha <- (juvfile$StGroup[[isp]][, shift(WageS, type = 'lead')] - 
                         rstan$vBM[isp + 1] * juvfile$StGroup[[isp]][, WageS]) * pred / StartEatenBy
        rstan$SplitAlpha[(first + 1):(last + 1), isp + 1] <- SplitAlpha[(first + 1):
                                                                          (last + 1)]
        sPred[ieco + 1] <- pred
      }
      #Carry over final split alpha to plus group
      rstan$SplitAlpha[rstan$Age2[isp + 1, rstan$Nstanzas[isp + 1] + 1] + 1, isp + 1] <- 
        rstan$SplitAlpha[rstan$Age2[isp + 1, rstan$Nstanza[isp + 1]], isp + 1]
    }
    
    #Misc parameters for C
    #KYA Spawn X is Beverton-Holt.  To turn off set to 10000. 2 is half saturation.
    #1.00001 or so is minimum
    rstan$SpawnX         <- c(0, rep(10000, rstan$Nsplit))
    rstan$SpawnEnergy    <- c(0, rep(1, rstan$Nsplit))
    eggs1<-eggs+1; rstan$baseEggsStanza <- eggs1-1
    #eggs1<-eggs+1; rstan$EggsStanza     <- eggs1-1
    #eggs1<-eggs+1; rstan$SpawnBio       <- eggs1-1
    eggs1<-eggs+1; rstan$baseSpawnBio   <- eggs1-1
    rstan$RscaleSplit    <- c(0, rep(1, rstan$Nsplit))
    #sPred1<-sPred+1; rstan$stanzaPred     <- sPred1-1
    sPred1<-sPred+1; rstan$baseStanzaPred <- sPred1-1
    
    # SplitSetPred(rstan, state)
  }
  
  if(juvfile$NStanzaGroups == 0){
    rstan <- list()
    rstan$Nsplit      <- juvfile$NStanzaGroups
    #Need leading zeros (+1 col/row) to make indexing in C++ easier
    rstan$Nstanzas       <- c(0, 0)
    rstan$EcopathCode    <- matrix(rep(0, 4), 2, 2)
    rstan$Age1           <- matrix(rep(0, 4), 2, 2)
    rstan$Age2           <- matrix(rep(0, 4), 2, 2)
    rstan$baseWageS      <- matrix(rep(0, 4), 2, 2)
    rstan$baseNageS      <- matrix(rep(0, 4), 2, 2)
    rstan$baseQageS      <- matrix(rep(0, 4), 2, 2)
    rstan$Wmat           <- c(0, 0)
    #rstan$Wmat001        <- c(0, 0)
    #rstan$Wmat50         <- c(0, 0)
    #rstan$Amat001        <- c(0, 0)
    #rstan$Amat50         <- c(0, 0)
    #rstan$WmatSpread <- -(rstan$Wmat001 - rstan$Wmat50)/MIN_REC_FACTOR
    #rstan$AmatSpread <- -(rstan$Amat001 - rstan$Amat50)/MIN_REC_FACTOR
    rstan$RecPower       <- c(0, 0)
    rstan$recruits       <- c(0, 0)
    rstan$VBGFd          <- c(0, 0)
    rstan$RzeroS         <- c(0, 0)
    rstan$vBM            <- c(0, 0)
    rstan$baseEggsStanza <- c(0, 0)
    #rstan$EggsStanza     <- c(0, 0)
    rstan$SplitAlpha     <- matrix(rep(0, 4), 2, 2)
    rstan$SpawnX         <- c(0, 0)
    rstan$SpawnEnergy    <- c(0, 0)
    #rstan$SpawnBio       <- c(0, 0)
    rstan$baseSpawnBio   <- c(0, 0)
    rstan$RscaleSplit    <- c(0, 0)
    rstan$baseStanzaPred <- c(0, 0)
    
  }
  
  
  return(rstan)
}